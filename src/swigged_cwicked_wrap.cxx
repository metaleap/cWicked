/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.3.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */


#define SWIG_VERSION 0x040300
#define SWIGC
/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif

#if defined(__cplusplus) && __cplusplus >=201103L
# define SWIG_NULLPTR nullptr
#else
# define SWIG_NULLPTR NULL
#endif 

/* -----------------------------------------------------------------------------
 * swigcompat.swg
 *
 * Macros to provide support compatibility with older C and C++ standards.
 *
 * Note that SWIG expects __cplusplus to be defined to the appropriate C++ standard.
 * MSVC users are urged to check and examine the /Zc:__cplusplus compiler option.
 * See https://learn.microsoft.com/en-us/cpp/build/reference/zc-cplusplus.
 * ----------------------------------------------------------------------------- */

/* C99 and C++11 should provide snprintf, but define SWIG_NO_SNPRINTF
 * if you're missing it.
 */
#if ((defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L) || \
     (defined __cplusplus && __cplusplus >= 201103L) || \
     defined SWIG_HAVE_SNPRINTF) && \
    !defined SWIG_NO_SNPRINTF
# define SWIG_snprintf(O,S,F,A) snprintf(O,S,F,A)
# define SWIG_snprintf2(O,S,F,A,B) snprintf(O,S,F,A,B)
#else
/* Fallback versions ignore the buffer size, but most of our uses either have a
 * fixed maximum possible size or dynamically allocate a buffer that's large
 * enough.
 */
# define SWIG_snprintf(O,S,F,A) sprintf(O,F,A)
# define SWIG_snprintf2(O,S,F,A,B) sprintf(O,F,A,B)
#endif

/* -----------------------------------------------------------------------------
 * clabels.swg
 *
 * Definitions of C specific preprocessor symbols.
 * ----------------------------------------------------------------------------- */

// this is used instead of default SWIGEXPORT symbol

#ifndef SWIGEXPORTC
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORTC
#   else
#     define SWIGEXPORTC __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORTC __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORTC
#   endif
# endif
#endif


#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <setjmp.h>

#define SWIG_contract_assert(expr, msg) if(!(expr)) { printf("%s\n", msg); SWIG_exit(0); } else


typedef struct SwigObj SwigObj;


#ifndef SWIG_exception
#define SWIG_exception(code, msg)
#endif


#ifdef __cplusplus
extern "C" {
#endif
SWIGEXPORTC int SWIG_exit(int code) { exit(code); }
#ifdef __cplusplus
}
#endif


#ifdef __cplusplus
#include <utility>
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigSmartPointer {
    T *ptr;
    SwigSmartPointer(T *p) : ptr(p) { }
    ~SwigSmartPointer() { delete ptr; }
    SwigSmartPointer& operator=(SwigSmartPointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
    void reset(T *p) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = p; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigSmartPointer tmp(new T(t)); pointer = tmp; return *this; }
#if __cplusplus >=201103L
  SwigValueWrapper& operator=(T&& t) { SwigSmartPointer tmp(new T(std::move(t))); pointer = tmp; return *this; }
  operator T&&() const { return std::move(*pointer.ptr); }
#else
  operator T&() const { return *pointer.ptr; }
#endif
  T *operator&() const { return pointer.ptr; }
  static void reset(SwigValueWrapper& t, T *p) { t.pointer.reset(p); }
};

/*
 * SwigValueInit() is a generic initialisation solution as the following approach:
 * 
 *       T c_result = T();
 * 
 * doesn't compile for all types for example:
 * 
 *       unsigned int c_result = unsigned int();
 */
template <typename T> T SwigValueInit() {
  return T();
}

#if __cplusplus >=201103L
# define SWIG_STD_MOVE(OBJ) std::move(OBJ)
#else
# define SWIG_STD_MOVE(OBJ) OBJ
#endif

#endif


#include "../pch/wi_pch.h"


namespace wi::version {
	long GetVersion() {
		return 0;
	}
}

#ifdef __cplusplus
extern "C" {
#endif

SWIGEXPORTC long wi_version_GetVersion() {
  long cppresult;
  long result;
  
  cppresult = (long)wi::version::GetVersion();
  result = (long)cppresult;
  return result;
}


SWIGEXPORTC int wi_version_GetMajor() {
  int cppresult;
  int result;
  
  cppresult = (int)wi::version::GetMajor();
  result = (int)cppresult;
  return result;
}


SWIGEXPORTC int wi_version_GetMinor() {
  int cppresult;
  int result;
  
  cppresult = (int)wi::version::GetMinor();
  result = (int)cppresult;
  return result;
}


SWIGEXPORTC int wi_version_GetRevision() {
  int cppresult;
  int result;
  
  cppresult = (int)wi::version::GetRevision();
  result = (int)cppresult;
  return result;
}


SWIGEXPORTC const char * wi_version_GetVersionString() {
  char *cppresult;
  const char * result;
  
  cppresult = (char *)wi::version::GetVersionString();
  result = (const char *)cppresult;
  return result;
}


SWIGEXPORTC const char * wi_version_GetCreditsString() {
  char *cppresult;
  const char * result;
  
  cppresult = (char *)wi::version::GetCreditsString();
  result = (const char *)cppresult;
  return result;
}


SWIGEXPORTC void wi_Application_delete(SwigObj* carg1) {
  wi::Application *arg1 = (wi::Application *) 0 ;
  
  arg1 = (wi::Application *) carg1;
  delete arg1;
}


SWIGEXPORTC void wi_Application_is_window_active_set(SwigObj* carg1, bool carg2) {
  wi::Application *arg1 = (wi::Application *) 0 ;
  bool arg2 ;
  
  arg1 = (wi::Application *) carg1;
  arg2 = (bool) carg2;
  if (arg1) (arg1)->is_window_active = arg2;
}


SWIGEXPORTC bool wi_Application_is_window_active_get(SwigObj* carg1) {
  bool cppresult;
  wi::Application *arg1 = (wi::Application *) 0 ;
  bool result;
  
  arg1 = (wi::Application *) carg1;
  cppresult = (bool) ((arg1)->is_window_active);
  result = (bool) cppresult;
  return result;
}


SWIGEXPORTC void wi_Application_allow_hdr_set(SwigObj* carg1, bool carg2) {
  wi::Application *arg1 = (wi::Application *) 0 ;
  bool arg2 ;
  
  arg1 = (wi::Application *) carg1;
  arg2 = (bool) carg2;
  if (arg1) (arg1)->allow_hdr = arg2;
}


SWIGEXPORTC bool wi_Application_allow_hdr_get(SwigObj* carg1) {
  bool cppresult;
  wi::Application *arg1 = (wi::Application *) 0 ;
  bool result;
  
  arg1 = (wi::Application *) carg1;
  cppresult = (bool) ((arg1)->allow_hdr);
  result = (bool) cppresult;
  return result;
}


SWIGEXPORTC void wi_Application_swapChain_set(SwigObj* carg1, SwigObj* carg2) {
  wi::Application *arg1 = (wi::Application *) 0 ;
  wi::graphics::SwapChain arg2 ;
  
  arg1 = (wi::Application *) carg1;
  arg2 = *(wi::graphics::SwapChain *)carg2;
  if (arg1) (arg1)->swapChain = arg2;
}


SWIGEXPORTC SwigObj* wi_Application_swapChain_get(SwigObj* carg1) {
  wi::graphics::SwapChain cppresult;
  wi::Application *arg1 = (wi::Application *) 0 ;
  SwigObj* result;
  
  arg1 = (wi::Application *) carg1;
  cppresult =  ((arg1)->swapChain);
  result = (SwigObj*)new wi::graphics::SwapChain(cppresult);
  return result;
}


SWIGEXPORTC void wi_Application_canvas_set(SwigObj* carg1, SwigObj* carg2) {
  wi::Application *arg1 = (wi::Application *) 0 ;
  wi::Canvas arg2 ;
  
  arg1 = (wi::Application *) carg1;
  arg2 = *(wi::Canvas *)carg2;
  if (arg1) (arg1)->canvas = arg2;
}


SWIGEXPORTC SwigObj* wi_Application_canvas_get(SwigObj* carg1) {
  wi::Canvas cppresult;
  wi::Application *arg1 = (wi::Application *) 0 ;
  SwigObj* result;
  
  arg1 = (wi::Application *) carg1;
  cppresult =  ((arg1)->canvas);
  result = (SwigObj*)new wi::Canvas(cppresult);
  return result;
}


SWIGEXPORTC void wi_Application_window_set(SwigObj* carg1, SwigObj* carg2) {
  wi::Application *arg1 = (wi::Application *) 0 ;
  wi::platform::window_type arg2 ;
  
  arg1 = (wi::Application *) carg1;
  arg2 = *(wi::platform::window_type *)carg2;
  if (arg1) (arg1)->window = arg2;
}


SWIGEXPORTC SwigObj* wi_Application_window_get(SwigObj* carg1) {
  wi::platform::window_type cppresult;
  wi::Application *arg1 = (wi::Application *) 0 ;
  SwigObj* result;
  
  arg1 = (wi::Application *) carg1;
  cppresult =  ((arg1)->window);
  result = (SwigObj*)new wi::platform::window_type(cppresult);
  return result;
}


SWIGEXPORTC void wi_Application_Run(SwigObj* carg1) {
  wi::Application *arg1 = (wi::Application *) 0 ;
  
  arg1 = (wi::Application *) carg1;
  (arg1)->Run();
}


SWIGEXPORTC void wi_Application_ActivatePath_pwi_RenderPath_f_wi_Color(SwigObj* carg1, SwigObj* carg2, float carg3, SwigObj* carg4) {
  wi::Application *arg1 = (wi::Application *) 0 ;
  wi::RenderPath *arg2 = (wi::RenderPath *) 0 ;
  float arg3 ;
  wi::Color arg4 ;
  
  arg1 = (wi::Application *) carg1;
  arg2 = (wi::RenderPath *) carg2;
  arg3 = (float) carg3;
  arg4 = *(wi::Color *)carg4;
  (arg1)->ActivatePath(arg2,arg3,SWIG_STD_MOVE(arg4));
}


SWIGEXPORTC void wi_Application_ActivatePath_pwi_RenderPath_f(SwigObj* carg1, SwigObj* carg2, float carg3) {
  wi::Application *arg1 = (wi::Application *) 0 ;
  wi::RenderPath *arg2 = (wi::RenderPath *) 0 ;
  float arg3 ;
  
  arg1 = (wi::Application *) carg1;
  arg2 = (wi::RenderPath *) carg2;
  arg3 = (float) carg3;
  (arg1)->ActivatePath(arg2,arg3);
}


SWIGEXPORTC void wi_Application_ActivatePath_pwi_RenderPath(SwigObj* carg1, SwigObj* carg2) {
  wi::Application *arg1 = (wi::Application *) 0 ;
  wi::RenderPath *arg2 = (wi::RenderPath *) 0 ;
  
  arg1 = (wi::Application *) carg1;
  arg2 = (wi::RenderPath *) carg2;
  (arg1)->ActivatePath(arg2);
}


SWIGEXPORTC SwigObj* wi_Application_GetActivePath(SwigObj* carg1) {
  wi::RenderPath *cppresult;
  wi::Application *arg1 = (wi::Application *) 0 ;
  SwigObj* result;
  
  arg1 = (wi::Application *) carg1;
  cppresult = (wi::RenderPath *)(arg1)->GetActivePath();
  result = (SwigObj*) cppresult;
  return result;
}


SWIGEXPORTC void wi_Application_setTargetFrameRate(SwigObj* carg1, float carg2) {
  wi::Application *arg1 = (wi::Application *) 0 ;
  float arg2 ;
  
  arg1 = (wi::Application *) carg1;
  arg2 = (float) carg2;
  (arg1)->setTargetFrameRate(arg2);
}


SWIGEXPORTC float wi_Application_getTargetFrameRate(SwigObj* carg1) {
  float cppresult;
  wi::Application *arg1 = (wi::Application *) 0 ;
  float result;
  
  arg1 = (wi::Application *) carg1;
  cppresult = (float)((wi::Application const *)arg1)->getTargetFrameRate();
  result = (float)cppresult;
  return result;
}


SWIGEXPORTC void wi_Application_setFrameSkip(SwigObj* carg1, bool carg2) {
  wi::Application *arg1 = (wi::Application *) 0 ;
  bool arg2 ;
  
  arg1 = (wi::Application *) carg1;
  arg2 = (bool) carg2;
  (arg1)->setFrameSkip(arg2);
}


SWIGEXPORTC void wi_Application_setFrameRateLock(SwigObj* carg1, bool carg2) {
  wi::Application *arg1 = (wi::Application *) 0 ;
  bool arg2 ;
  
  arg1 = (wi::Application *) carg1;
  arg2 = (bool) carg2;
  (arg1)->setFrameRateLock(arg2);
}


SWIGEXPORTC void wi_Application_Initialize(SwigObj* carg1) {
  wi::Application *arg1 = (wi::Application *) 0 ;
  
  arg1 = (wi::Application *) carg1;
  (arg1)->Initialize();
}


SWIGEXPORTC void wi_Application_Update(SwigObj* carg1, float carg2) {
  wi::Application *arg1 = (wi::Application *) 0 ;
  float arg2 ;
  
  arg1 = (wi::Application *) carg1;
  arg2 = (float) carg2;
  (arg1)->Update(arg2);
}


SWIGEXPORTC void wi_Application_FixedUpdate(SwigObj* carg1) {
  wi::Application *arg1 = (wi::Application *) 0 ;
  
  arg1 = (wi::Application *) carg1;
  (arg1)->FixedUpdate();
}


SWIGEXPORTC void wi_Application_Render(SwigObj* carg1) {
  wi::Application *arg1 = (wi::Application *) 0 ;
  
  arg1 = (wi::Application *) carg1;
  (arg1)->Render();
}


SWIGEXPORTC void wi_Application_Compose(SwigObj* carg1, SwigObj* carg2) {
  wi::Application *arg1 = (wi::Application *) 0 ;
  wi::graphics::CommandList arg2 ;
  
  arg1 = (wi::Application *) carg1;
  arg2 = *(wi::graphics::CommandList *)carg2;
  (arg1)->Compose(SWIG_STD_MOVE(arg2));
}


SWIGEXPORTC void wi_Application_SetWindow(SwigObj* carg1, SwigObj* carg2) {
  wi::Application *arg1 = (wi::Application *) 0 ;
  wi::platform::window_type arg2 ;
  
  arg1 = (wi::Application *) carg1;
  arg2 = *(wi::platform::window_type *)carg2;
  (arg1)->SetWindow(SWIG_STD_MOVE(arg2));
}


SWIGEXPORTC void wi_Application_SetFullScreen(SwigObj* carg1, bool carg2) {
  wi::Application *arg1 = (wi::Application *) 0 ;
  bool arg2 ;
  
  arg1 = (wi::Application *) carg1;
  arg2 = (bool) carg2;
  (arg1)->SetFullScreen(arg2);
}


SWIGEXPORTC void wi_Application_infoDisplay_set(SwigObj* carg1, SwigObj* carg2) {
  wi::Application *arg1 = (wi::Application *) 0 ;
  wi::Application::InfoDisplayer *arg2 = (wi::Application::InfoDisplayer *) 0 ;
  
  arg1 = (wi::Application *) carg1;
  arg2 = (wi::Application::InfoDisplayer *) carg2;
  if (arg1) (arg1)->infoDisplay = *arg2;
}


SWIGEXPORTC SwigObj* wi_Application_infoDisplay_get(SwigObj* carg1) {
  wi::Application::InfoDisplayer *cppresult;
  wi::Application *arg1 = (wi::Application *) 0 ;
  SwigObj* result;
  
  arg1 = (wi::Application *) carg1;
  cppresult = (wi::Application::InfoDisplayer *)& ((arg1)->infoDisplay);
  result = (SwigObj*) cppresult;
  return result;
}


SWIGEXPORTC bool wi_Application_IsFaded(SwigObj* carg1) {
  bool cppresult;
  wi::Application *arg1 = (wi::Application *) 0 ;
  bool result;
  
  arg1 = (wi::Application *) carg1;
  cppresult = (bool)((wi::Application const *)arg1)->IsFaded();
  result = (bool) cppresult;
  return result;
}


SWIGEXPORTC SwigObj* wi_Application_new() {
  wi::Application *cppresult;
  SwigObj* result;
  
  cppresult = (wi::Application *)new wi::Application();
  result = (SwigObj*) cppresult;
  return result;
}


SWIGEXPORTC void wi_arguments_Parse(int carg1, char ** carg2) {
  int arg1 ;
  char **arg2 = (char **) (char **)0 ;
  
  arg1 = (int) carg1;
  arg2 = (char * *) carg2;
  wi::arguments::Parse(arg1,arg2);
}


#ifdef __cplusplus
}
#endif

